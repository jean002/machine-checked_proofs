namespace gen_order

-- The binary relation g_o stands for the strict order <,
-- and the binary relation pw_o stands for the weak inequa-
-- lity <=.


constants {A : Type } (g_o : A → A → Prop)

def pw_o (x y : A) : Prop := ∀ w : A, (g_o w x → g_o w y) ∧ (g_o y w → g_o x w)
def asymmetric (A : Type) (g_o : A → A → Prop): Prop := ∀  x y : A, g_o x y → ¬ g_o y x
def g_transitive (A : Type) (g_o : A → A → Prop): Prop := ∀ x y z : A, (g_o x y ∧ g_o y z) → g_o x z
def positive_antisymmetric (A : Type) (pw_o : A → A → Prop): Prop := (∀ x y : A, (pw_o x y ∧ pw_o y x) → x = y)
def g_ordered_type (A : Type) (g_o : A → A → Prop) (pw_o : A → A → Prop): Prop := asymmetric A g_o ∧ g_transitive A g_o ∧ positive_antisymmetric A pw_o


theorem simple1: ∀ x y z : A, g_o x y ∧ pw_o y z → g_o x z :=

begin
   unfold pw_o,
   intros,
   cases a with h1 h2,
   let h3 : A := x,
   let h4 : (g_o x y → g_o x z) ∧ (g_o z x → g_o y x) := h2 x,
   apply (h4.left h1),
end

theorem simple2: ∀ x y z : A, pw_o y z ∧ g_o z x → g_o y x :=

begin
   unfold pw_o,
   intros,
   cases a with h1 h2,
   let h3 : A := x,
   let h4 : (g_o x y → g_o x z) ∧ (g_o z x → g_o y x) := h1 x,
   apply (h4.right h2),
end


theorem simple3: ∀ x y z : A, pw_o x y ∧ pw_o y z → pw_o x z :=

begin
   
   intros,
   cases a with h1 h2,
   unfold pw_o,
   intro,
   split,
   intro,
     apply simple1,
     split,
     apply simple1,
     split,
     exact a,
     exact h1,
     exact h2,
   intro,
     apply simple2,
     split,
     exact h1,
     apply simple2,
     split,
     exact h2,
     exact a,
end

theorem simple4: ∀ x y : A, g_transitive A g_o → g_o x y → pw_o x y :=

begin
   unfold pw_o g_ordered_type,
   intros,
   split,
   intro,
     apply a,
     split,
     exact a_2,
     exact a_1, 
   intro,
     apply a,
     split,
     exact a_1,
     exact a_2,
end

--Another weak inequality defined on a generalized ordered type follows:

def nw_o (x y : A) : Prop := ¬ g_o y x

theorem simple5: ∀ x : A, asymmetric A g_o → nw_o x x :=

begin
   unfold nw_o asymmetric,
   intros,
   intro,
   apply a,
   exact a_1,
   exact a_1,
end

theorem simple6: ∀ x y : A, asymmetric A g_o → pw_o x y → nw_o x y :=

begin
   unfold nw_o,
   intros,
   intro,
   let h1 : g_o y y,
   apply simple1,
   split,
   exact a_2,
   exact a_1,
   apply simple5,
   exact a,
   exact h1,
end

def cotransitivity (A : Type) (g_o : A → A → Prop): Prop := ∀ x y z : A, g_o x y → g_o x z ∨ g_o z y 


theorem simple7: cotransitivity A g_o → ∀ x y : A, nw_o x y → pw_o x y :=

begin
   unfold pw_o,
   intros,
   split,
   intro,
     let h1 : g_o w x → g_o w y ∨ g_o y x,
     apply (a w x y),
     let h2 : g_o w y ∨ g_o y x,
     apply (h1 a_2),
     destruct h2,
     intro,
       exact h,
     intro,
       let h3 : false,
       apply (a_1 h),
       contradiction,
   intro,
     let h4 : g_o y x ∨ g_o x w,
     apply (a y w x),
     assumption,
     destruct h4,
     intro,
       let h5 : false := a_1 h,
       contradiction,
     intro,
       assumption,
end

def negative_antisymmetry (A : Type) (nw_o : A → A → Prop): Prop := ∀ x y : A, nw_o x y ∧ nw_o y x → x = y


theorem simple8: asymmetric A g_o → negative_antisymmetry A nw_o → positive_antisymmetric A pw_o :=

begin
  unfold negative_antisymmetry positive_antisymmetric,
  intros,
  apply (a_1 x y),
  split,
  apply simple6,
    assumption,
    exact a_2.left,
  apply simple6,
    assumption,
    exact a_2.right,
end

theorem simple9: asymmetric A g_o → cotransitivity A g_o → g_transitive A g_o :=

begin
  unfold asymmetric cotransitivity g_transitive,
  intros,
  let h1 : g_o x y → g_o x z ∨ g_o z y := a_1 x y z,
  let h2 : g_o x z ∨ g_o z y := h1 a_2.left,
  destruct h2,
  intro,
    assumption,
  intro,
    let h3 : g_o y z → ¬ g_o z y := a y z,
    let h4 : ¬ g_o z y := h3 a_2.right,
    contradiction,
end

-- We show that Prop is a generalized ordered type. We first define
-- a binary relation on Prop.

def g_o_1 (p q : Prop) : Prop := ¬ p ∧ q

-- The following weak inequality is a special case of "pw_o" defined above.

def pw_o_1 (p q : Prop) : Prop := ∀ r : Prop, (g_o_1 r p → g_o_1 r q) ∧ (g_o_1 q r → g_o_1 p r)

-- We introduce the univalence axiom for Prop. For more on the univalence axiom
-- see https://homotopytypetheory.org/book/.

axiom univalence_for_Prop : ∀ p q : Prop, (p → q) ∧ (q → p) → p = q 

theorem simple10: asymmetric Prop g_o_1 := 

begin
  unfold asymmetric,
  unfold g_o_1,
  intros,
  intro,
  apply (a.left a_1.right),
end

theorem simple11: g_transitive Prop g_o_1 :=

begin
  unfold g_transitive,
  unfold g_o_1,
  intros,
  split,
  exact a.left.left,
  exact a.right.right,
end

lemma simple12: ∀ p q : Prop, pw_o_1 p q → (p → q) :=

begin
  unfold pw_o_1,
  intros,
  let h : Prop := false,
  let h1 : (g_o_1 false p → g_o_1 false q) ∧ (g_o_1 q false → g_o_1 p false) := a h,
  let h2 : ¬ false ∧ p,
  split,
  intro,
    contradiction,
  assumption,
  let h3 : g_o_1 false q := h1.left h2,
  exact h3.right,
end

lemma simple13: ∀ p q : Prop, (pw_o_1 p q ∧ pw_o_1 q p) → ((p → q) ∧ (q → p)) :=

begin
  intros,
  split,
  apply simple12,
    exact a.left,
  apply simple12,
    exact a.right,
end

-- We need the univalence axiom for Prop to prove the following.

theorem simple14: positive_antisymmetric Prop pw_o_1:=

begin
  unfold positive_antisymmetric,
  intros,
  let h : (x → y) ∧ (y → x) := simple13 x y a,
  apply univalence_for_Prop x y h,
end

theorem simple15: g_ordered_type Prop g_o_1 pw_o_1 :=

begin
  split,
  apply simple10,
  split,
  apply simple11,
  apply simple14,
end

def LEM : Prop := ∀ p : Prop, p ∨ ¬ p

theorem simple16: cotransitivity Prop g_o_1 → LEM :=

begin
  unfold cotransitivity,
  intros,
  unfold LEM,
  intro,
  let h : g_o_1 false true,
  let h1 : ¬ false,
  contradiction,
  let h2 : true,
  trivial,
  split,
  assumption,
  assumption,
  let h3 : g_o_1 false true → g_o_1 false p ∨ g_o_1 p true := a false true p,
  let h4 : g_o_1 false p ∨ g_o_1 p true := h3 h,
  destruct h4,
  intro,
    apply or.inl h_1.right,
  intro,
    apply or.inr h_1.left,
end

inductive Fintype : Type
| a : Fintype
| b : Fintype
| c : Fintype

inductive rel : Fintype → Fintype →  Prop 
| r1 : rel Fintype.a Fintype.b
| r2 : ∀ p : Prop, (p → rel Fintype.a Fintype.c )
| r3 : ∀ p : Prop, (¬ p → rel Fintype.c Fintype.b) 


axiom asymmetry_for_Fintype : ∀ x y : Fintype, rel x y → ¬ rel y x
axiom trivial1 : ¬ rel Fintype.c Fintype.a
axiom trivial2 : ¬ rel Fintype.b Fintype.c
axiom trivial3 : ∀ p : Prop, rel Fintype.a Fintype.c → p 
axiom trivial4 : ∀ p : Prop, rel Fintype.c Fintype.b → ¬ p


-- We define two weak binary relations with respect to any type and any binary relation
-- on that type. 

def nw_o_2 (X : Type) (binrel : X → X → Prop) (x y : X) : Prop := ¬ binrel y x
def pw_o_2 (X : Type) (binrel : X → X → Prop )(x y : X) : Prop := ∀ z : X, (binrel z x → binrel z y) ∧ (binrel y z → binrel x z)

-- We need this lemma to prove the next theorem.

lemma simple17: ∀ x y : Fintype, nw_o_2 Fintype rel x y → pw_o_2 Fintype rel x y :=

begin
  unfold nw_o_2 pw_o_2,
  intros,
  repeat{induction x},
  repeat{induction y},
  repeat{induction z},
  all_goals{split},
  all_goals{intro},
  repeat{trivial},
  repeat{assumption},
  let h1 : ¬ rel Fintype.a Fintype.a := asymmetry_for_Fintype Fintype.a Fintype.a a_1, contradiction,
  let h2 : ¬ rel Fintype.b Fintype.b := asymmetry_for_Fintype Fintype.b Fintype.b a_1, contradiction,
  apply (rel.r3 (rel Fintype.b Fintype.a)) a,
  apply (rel.r2 (rel Fintype.b Fintype.c)) a_1,
  let h3 : ¬ rel Fintype.a Fintype.a := asymmetry_for_Fintype Fintype.a Fintype.a a_1, contradiction,
  let h4 : false := ((asymmetry_for_Fintype Fintype.a Fintype.b) rel.r1) a_1, contradiction,
  let h5 : false := ((trivial4 ¬rel Fintype.c Fintype.a ) a_1) a, contradiction,
  let h6 : ¬ rel Fintype.c Fintype.c := asymmetry_for_Fintype Fintype.c Fintype.c a_1, contradiction,
  let h1 : ¬ rel Fintype.a Fintype.a := asymmetry_for_Fintype Fintype.a Fintype.a a_1, contradiction,
  let h2 : ¬ rel Fintype.b Fintype.b := asymmetry_for_Fintype Fintype.b Fintype.b a_1, contradiction,
  let h7 : false := a rel.r1, contradiction,
  let h7 : false := a rel.r1, contradiction,
  apply rel.r2 (rel Fintype.a Fintype.b) a_1,
  let h8 : false := trivial1 a_1, contradiction,
  let h2 : ¬ rel Fintype.b Fintype.b := asymmetry_for_Fintype Fintype.b Fintype.b a_1, contradiction,
  let h6 : ¬ rel Fintype.c Fintype.c := asymmetry_for_Fintype Fintype.c Fintype.c a_1, contradiction,
  let h1 : ¬ rel Fintype.a Fintype.a := asymmetry_for_Fintype Fintype.a Fintype.a a_1, contradiction,
  let h9 : false := trivial2 a_1, contradiction,
  apply (rel.r3 (rel Fintype.a Fintype.c)) a,
  let h6 : ¬ rel Fintype.c Fintype.c := asymmetry_for_Fintype Fintype.c Fintype.c a_1, contradiction,
  exact rel.r1,
  let h10 : false := (asymmetry_for_Fintype Fintype.a Fintype.b) rel.r1 a_1, contradiction,
  let h2 : ¬ rel Fintype.b Fintype.b := asymmetry_for_Fintype Fintype.b Fintype.b a_1, contradiction,
  let h6 : ¬ rel Fintype.c Fintype.c := asymmetry_for_Fintype Fintype.c Fintype.c a_1, contradiction,
end

theorem simple18: (∀ Y : Type, ∀ binrel2 : Y → Y → Prop, ((∀ x y : Y, nw_o_2 Y binrel2 x y → pw_o_2 Y binrel2 x y) → cotransitivity Y binrel2)) → LEM :=

begin
  unfold cotransitivity LEM,
  intros,
  let h1 : cotransitivity Fintype rel := a Fintype rel simple17,
  let h2 : rel Fintype.a Fintype.c ∨ rel Fintype.c Fintype.b := (h1 Fintype.a Fintype.b Fintype.c) rel.r1,
  destruct h2,
  intro,
    apply or.inl (trivial3 p h),
  intro,
    apply or.inr (trivial4 p h),  
end

end gen_order
  

  

  
